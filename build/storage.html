<!doctype html>
<!--[if lte IE 9]><html class="ie"><![endif]-->
<!--[if gt IE 9]><!--><html><!--<![endif]-->
<head>
  <title>Javascript for the Web Savvy &bull; Cookies and Local Storage</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">
  <link rel="stylesheet" href="css/styles.css" type="text/css">
  <script src="../js/require.js"></script>
  <script>
  require.config({
    baseUrl: 'js',
    paths: {
      jquery: 'jquery-1.9.min'
    }
  });
  </script>
</head>
<body>
  <!--<div class="navigation">
    <a href="./">&laquo; Table of Contents</a>
  </div>-->
  <h1>Cookies and Local Storage</h1>
  <div class="content">

<h2>Toll House</h2>

<p>
  The origins of the term "cookie" on the web are an interesting story. Early Netscape engineers needed a way for the server to identify a browser between requests. Normally, there's no information shared between one page load and another, unless it's awkwardly tagged onto the URL. This makes the web a <mark>stateless</mark> system: each page load is a fresh request all on its own. Unfortunately, there are many applications where we need to track users for legitimate reasons, such as keeping you logged into a service.

<p>
  To solve this problem, Netscape implemented a "magic cookie," which was then shortened to cookie. These are small pieces of information that the server could ask the browser to hold onto and send back to the server with every future request. So, for example, a retail site might ask the browser to store a cookie containing your encrypted user ID. From that point on, every page request will include the cookie, so that the server can decrypt your username and show you the correct shopping cart. The browser doesn't have the decryption key (it just passes back whatever value it was given), so your credentials are safe from prying eyes, which is ostensibly the "magic" part. It's not exactly Penn and Teller, but it's a useful sleight of hand.

<p>
  It's not just servers that can set cookies, however. JavaScript was given that ability early on, and for a long time it was the only option available if a programmer wanted to store information on a user's computer--say, for configuration settings, or to show pop-ups only to first-time visitors. JavaScript cookies are just like server cookies in that they're also sent to the server, which is an extremely useful capability. In the last few years, alternatives for local storage have been created for web browsers, but they don't get copied with requests and they're still not supported by all legacy browsers, so cookies still have their place in the ecosystem.

<p>
  Cookies have gotten a bad rap over the years, mostly due to the privacy implications of user-tracking cookies. Some of this is deserved, and some of it is evening-news hysteria. The truth is more complicated, since cookies actually operate under a fairly strict security policy. A cookie will only be sent back to the site that created it--other sites can't even tell it's there. Cookies can also only store a small amount of data. Finally, "HTTP-only" cookies are not available to JavaScript: they can only be set and read by a server, so malicious scripts can't read them.

<h2>Your Cookie Recipe</h2>

<p>
  Because they are one of the oldest features in the browser (Netscape 2.0!), cookies don't really have an API so much as they have quirks and inconveniences. JavaScript can access the current document's cookies by using the <var>cookie</var> property on the <var>document</var> global object. You set and get cookies through this property, but they don't behave in consistent ways. To see what I mean, open up your dev tools on a site that is likely to have set cookies--say, <a href="http://www.google.com">google.com</a>--and type the following lines into the console:

<code>
document.cookie;
document.cookie = "testCookie=1";
document.cookie;
</code>

<p>
  What you should see when you get the value of <var>document.cookie</var> is a long string of gibberish that Google uses to keep track of who you are between searches. The weird thing is that when you set <var>document.cookie</var> to a new value, that gibberish doesn't go away. Instead, your text gets jammed onto the end of it. That's because the string value of this property isn't really a string at all--it's a representation of the behind-the-scenes cookie storage for your browser.

<p>
  You can view this storage in several places, but the easiest is through a good developer toolkit. The Chrome dev tools display all cookies for a site on the Resources tab, and the Firebug extension for Firefox now includes a dedicated cookies tab. Sadly, the built-in Firefox dev tools do not yet include a good way to view cookies, but they are all listed behind a link in the "privacy" section of the Firefox options.

<p>
  Viewing the cookie we just set, you may notice that it's marked as a "session" cookie. This means it will only be stored as long as the browser is open. When the user closes their browser, all session cookies are erased. If we want to store this for a longer period of time, we need to add some extra parameters to our cookie string, as shown in the table below. Parameters must be separated from each other with semicolons.

<table>
  <tr>
    <th>Parameter
    <th>Notes
  <tr>
    <td>path
    <td>This sets the path in which the cookie is applied. If you don't specify a path, it'll use the current folder, which is probably not what you want. Most people set the path equal to the root of the site, as in the example, so that their cookies are available anywhere.
      <code>"val=1;path=/";</code>
  <tr>
    <td>domain
    <td>Like the path, but for your domains. You can use this to set a cookie from a subdomain, such as <var>www.example.com</var>, across all subdomains for <var>example.com</var> by putting a dot in front of the value. If you leave this out, it'll use your current domain, which is usually fine.
      <code>"val=1;domain=.example.com";</code>
  <tr>
    <td>expires
    <td>The Expires parameter is the really important one, because it sets permanent (non-session cookies) that will last until their expiration date. The date must be expressed as a Greenwich Mean Time date string, so in the example we use the <var>Date()</var> constructor and its <var>toGMTString</var> method to create one for us, expiring on January 1, 2025.

      <code>
"val=1;expires=" + (new Date(2025, 0, 1).toGMTString());
      </code>
  <tr>
    <td>secure
    <td>Secure cookies are only sent to the server over an HTTPS connection. This is safer on public networks, and should be used for user-sensitive information whenever possible.
      <code>"val=1;secure";</code>
</table>

<p>
  Getting the current cookies is also frustrating: you have to find your specific cookie within the long string value, then find the value that follows after the equals sign. This entire process is so cumbersome that even Mozilla provides a <a href="https://developer.mozilla.org/en-US/docs/Web/API/document.cookie">simpler get/set API sample</a> on the documentation page for <var>document.cookie</var>. We can, however, write a simpler wrapper around cookies in only a few lines of code.

<code>
var getCookie = function(name) {
  //divide the cookie string up by semicolons,
  //which separate key/value pairs
  var pairs = document.cookie.split(/;\s*/)
  for (var i = 0; i &lt; pairs.length; i++) {
    //split each pair into its key and value via the =
    var split = pairs[i].split("=");
    //search for a key matching our name argument
    if (split[0] == name) {
      return split[1]
    }
  }
  //if nothing matched, return null
  return null;
}

var setCookie = function(name, value) {
  //let's just set long-lived cookies
  var expires = new Date(2025, 0, 1).toGMTString();
  var path = "/";
  var set = name + "=" + value;
  //join all these with semicolons between them
  var cookieString = [set, path, expires].join(';');
  document.cookie = cookieString;
}
</code>

<h2>Local Storage</h2>

<p>
  In contrast with the cookie system, the <var>localStorage</var> and <var>sessionStorage</var> APIs were designed to be much easier to use. Both objects are attached to the <var>window</var> global, which means that we can refer to them directly, and they provide a set of easy methods for interacting with their contents. 

<code>
localStorage.setItem("one", "stored"); //store a value as "one"
localStorage.getItem("one"); //returns "stored"
localStorage.removeItem("one"); //deletes this item from storage

localStorage.setItem("two", 2);
//all items are stored as strings
localStorage.getItem("two"); //returns "2"

localStorage.length; //returns 1, since only "two" is still there
localStorage.clear(); //removes all items

//You can also treat localStorage as a regular object.
localStorage["three"] = "hello, world";

//sessionStorage works the same way, but will be cleared when the browser is closed
sessionStorage.setItem("forgetMe", "true");
</code>

  Like cookies, <var>localStorage</var> is isolated on a per-site basis and will only store strings, but it can hold a much larger amount of data. If you want to store large objects, you can use the JSON parser built into the browser--<var>JSON.stringify()</var> to convert objects to text, and <var>JSON.parse()</var> to convert them back.

<h2>Example Code</h2>

<p>
  Support for the local storage APIs is actually very good: it's in all modern browsers, including IE 8 and higher. That said, it's a good exercise to write a storage API that can seamlessly switch between cookies and <var>localStorage</var> in older browsers. We call this kind of fallback a <mark>polyfill</mark>: unlike a shim, it gives us a new API that degrades gracefully depending on the browser's capabilities. In many cases, given the general clumsiness of the built-in browser functions, it can actually be more pleasant than the real thing.

<div class="interactive timelapse" id="storage">
  <div class="controls">
    <a class="first">First</a>
    <a class="previous">Previous</a>
    <ul class="revision-list"></ul>
    <a class="next">Next</a>
    <a class="last">Last</a>
  </div>
  <aside class="comments-container">
    <h1 class="comments-bar">COMMENTS</h1>
    <div class="comments"></div>
  </aside>
  <code class="revision"></code>
<script type="text/timelapse">var storage = {
    get: function(key) {
@,0@        
@1,@        if (typeof window.localStorage == "undefined") {
@1,@            //use cookie
@4,@            var cookies = document.cookie.split(/;\s*/);
@4,@            for (var i = 0; i < cookies.length; i++) {
@4,@            var pair = cookies[i].split("=");
@4,@                if (pair[0] == key) {
@4,@                    return pair[1];
@4,@                }
@4,@            }
@4,@            return null;
@1,@        } else {
@1,@            //use localStorage
@2,@            window.localStorage.getItem(key);
@1,@        }
    },
    set: function(key, value) {
@,0@        
@1,@        if (typeof window.localStorage == "undefined") {
@1,@            //use cookie
@3,@            var expires = new Date();
@3,@            //set expiration for 1 year in the future
@3,@            expires.setFullYear(expires.getFullYear() + 1);
@3,@            expires = expires.toGMTString();
@3,@            document.cookie = key+"="+value+";path=/;expires="+expires;
@1,@        } else {
@1,@            //use localStorage
@2,@            window.localStorage.setItem(key, value);
@1,@        }
    },
    remove: function(key, value) {
@,0@        
@1,@        if (typeof window.localStorage == "undefined") {
@1,@            //use cookie
@5,@            var value = this.get(key);
@5,@            var expires = new Date();
@5,@            expires.setFullYear(1981);
@5,@            expires = expires.toGMTString();
@5,@            document.cookie = key+"=null;path=/;expires="+expires;
@1,@        } else {
@1,@            //use localStorage
@2,@            window.localStorage.removeItem(key);
@1,@        }
    }
};
@@c:0;Our <var>storage</var> object will use localStorage if it exists, but otherwise it will use cookies as a fallback. We'll start by stubbing out the three methods it uses: <var>get</var>, <var>set</var>, and <var>remove</var>@@
@@c:1;In each of our methods, we'll add a feature-detection statement to decide whether to use <var>localStorage</var> or cookies. In browsers that don't support the new storage mode, <var>typeof window.localStorage</var> will return "undefined"--in those browsers, we need to use cookies instead.@@
@@c:2;Our storage methods map cleanly to the local storage API, so we can go ahead and fill those in.@@
@@c:3;Let's start with set, since it's the easiest to test. We'll need to construct a cookie string that expires one year from now, and then assign it to <var>document.cookie</var> to save it. 

We can test that this works by calling <var>storage.set()</var> from the console, then looking at <var>document.cookie</var>, but first we'll have set the condition to "true" temporarily--otherwise our polyfill will use <var>localStorage</var> as intended.@@
@@c:4;Now we can add our <var>get()</var> method. It should look familiar from the code we wrote earlier for getting and setting cookies.@@
@@c:5;Finally, we just add a quick removal method, by assigning the cookie with a null value and a date in the past.@@</script>
</div>
<script>
require(['jquery', 'meta/TLPlayer'], function($, Player) {
  var element = $('#storage');
  var player = new Player();
  var diff = element.find('script[type="text/timelapse"]');
  var revUL = element.find('ul.revision-list');
  player.load(diff.html()).done(function() {
    player.timelapse.revisions.forEach(function(item, i) {
      var li = $('<li>');
      li.html(i + 1);
      li.attr('data-revision', i);
      revUL.append(li);
    });
    player.connect({
      code: element.find('code.revision'),
      comments: element.find('.comments')
    })
    player.switch(0);
    element.find('li:first').addClass('active');
    element.find('.controls').on('click', 'li', function() {
      var $this = $(this);
      element.find('.active').removeClass('active');
      $this.addClass('active');
      player.switch($this.attr('data-revision'));
    });
    /*element.find('.comments').slideUp();
    element.find('.comments-bar').on('click', function() {
      element.find('.comments').slideToggle();
    });*/
    ['first', 'previous', 'next', 'last'].forEach(function(jump) {
      element.find('.' + jump).click(function() {
        player[jump]();
        element.find('.active').removeClass('active');
        element.find('li[data-revision=' + player.current + ']').addClass('active');
      });
    });
  });
});
</script>

<script>
require(['jquery', 'google-code/prettify'], function($) {
  $('code, pre').each(function() { $(this).html($.trim(this.innerHTML)) }).addClass('prettyprint');
  PR.prettyPrint();
});
</script>
  </div>
</body>
</html>