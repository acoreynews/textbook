<!doctype html>
<!--[if lte IE 9]><html class="ie"><![endif]-->
<!--[if gt IE 9]><!--><html><!--<![endif]-->
<head>
  <title>Javascript for the Web Savvy &bull; Object Lesson</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">
  <link rel="stylesheet" href="css/styles.css" type="text/css">
  <script src="../js/require.js"></script>
  <script>
  require.config({
    baseUrl: 'js',
    paths: {
      jquery: 'jquery-1.9.min'
    }
  });
  </script>
</head>
<body>
  <!--<div class="navigation">
    <a href="./">&laquo; Table of Contents</a>
  </div>-->
  <h1>Object Lesson</h1>
  <div class="content">

<h2>Objects as Simulation</h2>

<p>
  Let's say you wanted to write a computerized catalog for a library. You'd have a lot of information to manage, both for each book and for the total collection. Certainly you'd need some arrays, since you'll be adding new books all the time, and won't want to keep individual variables for each one. Even for the books themselves, it would be good to have all the information on each book grouped together. For example, you'll want to store:

  <ul>
    <li> Title
    <li> Author
    <li> Number of pages
    <li> Call number
    <li> Publication date
    <li> Subjects
    <li> Description
  </ul>

<p>
  One way to keep these things collected would be to use an array, and use set indexes for each property. <var>book[0]</var> might be the title, for example, and <var>book[1]</var> would be the author, and so on. But this is pretty awkward: each time you need to get the title, you have to remember that the index for title is 0, which is easy to forget. Someone maintaining your code is not going to thank you for that!

<p>
  What you really need is a kind of array where, instead of using numbers, you could just name the values inside. Luckily, you can! An object, in JavaScript, is a collection like an array, but with string indexes instead of numerical ones. You declare an object using curly braces instead of the square braces that we use for arrays, and then the syntax is basically identical:

<code>
var book = {};
book["author"] = "Frank Herbert";
book["title"] = "Dune";
book["pagecount"] = 567;
book["subjects"] = ["Science Fiction", "Ecology", "Doom"];

console.log(book["pagecount"]); //logs out 567;
</code>

<aside>

  <h1>typeof object</h1>

  <p>
    Objects and arrays are collections that contain primitives, but they're also their own kind of value, as evidenced by the fact that they have a different result when fed to the <var>typeof</var> keyword. It's good to know that you can distinguish them from the primitive types if you need to.

<code>
typeof {};
</code>
<samp>
'object'
</samp>

  <p>
    Unfortunately, one casualty of the short timeframe under which JavaScript was created is the way <var>typeof</var> handles arrays. They don't return 'array'--instead, they masquerade as a different type.

<code>
typeof [];
</code>
<samp>
'object'
</samp>

  <p>
    There is not a great cross-browser answer, unfortunately, to the problem of distinguishing between objects and arrays if this is something that you really need to do. Both objects and arrays can have numbered properties and named properties. They share some of the same built-in functions. If you have a favorite JavaScript library, like jQuery or YUI, it may provide a method for checking between the two. Otherwise, I usually treat it as an array if it has a <var>length</var> property and hope for the best.


</aside>

<p>
  In this case, we first define book as an empty object. Then we add <mark>properties</mark> to the object, specifying the <mark>key</mark> for each with a string in brackets instead of a number and setting it equal to the desired value. What we call "indexes" for arrays are called "keys" on objects, but they serve the same role: to serve as a lookup address for the value inside the list. For our book, the key "author" is set to "Frank Herbert", and so forth. Just as with arrays, we can put any value into an object, including other objects and (as in the <var>subjects</var> property) arrays.

<p>
  Object keys that are quoted this way can be any possible string. If you stick to the rules for variable names, though, there's a much shorter and easier way to talk about object properties. Properties that start with a letter and contain only letters, numbers, and the $ or _ characters, can be referenced using a dot instead of the square brackets.

<code>
var book = {};
book.author = "Frank Herbert";
book.title = "Dune";

console.log(book.title + ", by " + book.author);
//logs "Dune, by Frank Herbert"
</code>

<p>
  This should start to look a little familiar, because we've used a few objects so far. For example, whenever we want to print something out to the console, we've been using <var>console.log()</var>: the <var>console</var> variable is an object that contains a number of useful functions--not just <var>log</var>, but also <var>error</var>, <var>warn</var>, and <var>info</var>, each of which prints a different kind of message to the console. If you type "console." (with the dot) into your console, most browsers will bring up a list of all the properties in the object that you can browse through.

<p>
  Other objects that are built-in to the browser include:

  <ul>
    <li><var>window</var> - contains all <mark>global</mark> variables, including ones you declare for yourself. All variables that you define from the console are actually properties on the window object, as though you're "inside" it.
    <li><var>Math</var> - contains a bunch of useful functions like <var>round()</var> and <var>sqrt</var> for doing calculations, along with some handy values like Math.PI.
    <li><var>document</var> - the current page as loaded into the browser. We'll do more stuff with the document in a bit.
  </ul>

<aside>

  <h1>Everything's an Object</h1>

  <p>
    Although we're talking here about uppercase-o Objects as a specific data type, everything in JavaScript is an object, or is capable of being treated like an object. Strings, for example, have a <var>length</var> property just like arrays.

<code>
var test = "abcd";
console.log(test.length); // 4
</code>

  <p>
    All the primitive types have a number of properties and helper functions attached to them. Many of these, particularly in the case of strings, can be very helpful: you can convert a string <var>toUpperCase()</var>, run a <var>search()</var> for a sub-string, or <var>split()</var> it into its component parts. For more information on these helper functions, check out the Mozilla documentation:

    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String#String_instances">Strings</a>
      <li><a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number#Number_instances">Numbers</a>
      <li><a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array#Array_instances">Arrays</a>
      <li><a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object#Object_instances">Objects</a>
    </ul>

</aside>

<p>
  Creating our own objects, however, is the really exciting part. We can do so using the syntax above, where we create an empty object and add properties. But there's also a <mark>literal</mark> syntax for declaring objects in a single step, the same way that we declare other literal values like numbers, strings, and booleans by just writing them into our code. To define our book as an object literal, we'd do this:

<code>
var book = {
  author: "Frank Herbert",
  title: "Dune",
  subjects: ["Science Fiction", "Ecology", "Doom"]
};

console.log(book.title); //prints "Dune"
</code>

  This syntax is a bit like declaring an array. In that case, we could add the starting values to the array by just listing them with commas between each item. In this case, we also list the object's properties separated by commas, but we have to specify the key for each value first, separated from its value with a colon. Be careful not to add a trailing comma after the last key:value pair--in some browsers, that will cause an error.

<h2>Looping through Objects</h2>

<p>
  Objects are useful because they let us simulate real world objects easily, but they can also serve as "named lists" in contrast to the "numbered lists" of arrays. For example, you might create an object containing all the people in a group, using their first names as the keys and their lunch orders as the values:

<code>
var group = {
  "Thomas": "Chicken salad sandwich",
  "Belle": "Cobb salad",
  "Wallace": "Cheese pizza"
};
</code>

  Now, if we want to list out everyone's lunch order it's easy to do, as long as we know how to write a <var>for...in</var> loop for objects.

<code>
for (var key in group) {
  console.log(key + " ordered " + group[key]);
}
</code>

  This loop looks different, and with good reason. After all, arrays are predictable: they (mostly) start at 0 and (mostly) index their contents on ascending numbers. For objects, though, the key could be any string, and we can hardly be expected to start at "a" and work our way up through "zzzzzzzzzzzzz" to find them. 

<p>
  Instead, when we write a <var>for...in</var> loop, JavaScript will loop through the object for us and assign each key (<i>not</i> each value) to the variable we provide. You can name that variable anything you want, as long as it's followed by <var>in o</var>, where "o" is the name of the object you want to loop through. I always find it useful to create a new variable with a predictable name, as above (where I've named it "key" for self-evident reasons). 

<p>
  Remember, however, that this is not the value. It's the key--the string name of the property that we can use to find the actual value with the square brackets syntax, just as our array loops used <var>array[i]</var> to find the actual value of each item in <var>array</var>. Unfortunately, you can't use the dot syntax inside a loop, because we don't know the actual name of the variable during each repetition. Only in the square brackets will the value of your key variable--and not its name--be used to look up a value from your object.

<code>
var movie = {
  title: "Alien",
  director: "Ridley Scott",
  star: "Sigourney Weaver"
};

for (var prop in movie) {
  console.log(prop); //"title", "director", "star"

  //WRONG - this logs "undefined" because movie has no property named "prop"
  console.log(movie.prop); 

  //RIGHT - this logs the value of each property inside movie
  console.log(movie[prop]); //"Alien", "Ridley Scott", "Sigourney Weaver"
}
</code>

<h2>Construction with Objects</h2>

<p>
  Using objects gives us a way to create strongly-related values, by combining them under a single variable. By combining them with arrays and other objects, we can write code that is readable, elegant, and efficient. Let's work through an example using some real-world data that uses all the skills we've picked up over the last few chapters: <var>if/else</var>, <var>for</var> loops, arrays, and objects.

<code>
var quakes = [
  {
    magnitude: 4.3,
    location: "Seattle"
  },
  {
    magnitude: 2.7,
    location: "San Francisco"
  },
  {
    magnitude: 5.4,
    location: "Las Vegas"
  }
  {
    magnitude: 1.8,
    location: "Washington, DC"
  }
];
</code>

<p>
  The above code sets up an array full of earthquake data. There are only four quakes in our set, but there could easily be more. The advantage of using a loop over this information is that it would scale, whether it was four earthquakes or four thousand. Now, we're going to look through our data and find out where the largest quake took place. First, we'll set up a variable to contain the highest quake we've found so far. We'll go ahead and assign the first earthquake to the variable, since we need some starting values.

<code>
var highest = quakes[0];
</code>

<p>
  Then we'll loop over the quakes array, checking each item in turn. If it's higher in magnitude than the quake stored in <var>highest</var>, we'll store it in <var>highest</var> instead and keep going.

<code>
for (var i = 0; i &lt; quakes.length; i++) {
  var current = quakes[i]; //get the current quake object
  if (current.magnitude &gt; highest.magnitude) { //check against highest
    highest = current; //if higher, reassign highest
  }
}
console.log("The biggest earthquake took place in " + highest.location);
</code>

<p>
  Problems like this start to show how objects and loops can make many tough problems trivially solveable. Sure, it's easy to find the biggest quake when there are only three items. When there are many more, however, or the comparisons become more complicated, you'll be glad to let the computer handle this kind of manual labor.

<h2>Example Code</h2>

<p>
  For this chapter's sample, we'll combine objects and arrays again to examine another interesting data set (for certain values of interesting). In the code below, we define an array containing a series of on-screen objects from a video game, and we're going to filter it down to only those that match certain criteria. For exapmle, we may only want the monsters, or power-ups. We might want to do this in order to determine if the player is in contact with anything that would hurt or help her, or to do collision detection for the level structure itself. Filtering down a large, diverse collection into smaller subsets is a common task in programming, from video games to word-processing.

<div class="interactive timelapse" id="game-objects">
  <div class="controls">
    <a class="first">First</a>
    <a class="previous">Previous</a>
    <ul class="revision-list"></ul>
    <a class="next">Next</a>
    <a class="last">Last</a>
  </div>
  <aside class="comments-container">
    <h1 class="comments-bar">COMMENTS</h1>
    <div class="comments"></div>
  </aside>
  <code class="revision"></code>
<script type="text/timelapse">var gameObjects = [{
    type: "Monster",
    health: 10,
    x: 20,
    y: 30
}, {
    type: "Bonus",
    score: 1000,
    x: 45,
    y: 10
}, {
    type: "Fence",
    height: 20,
    x: 10,
    y: 0
}];
@1,@
@2,@var notFence = [];
@3,@var lowAltitude = [];
@4,@var typeCounter = {};
@2,@
@1,@for (var i = 0; i < gameObjects.length; i++) {
@1,1@    
@2,@    var item = gameObjects[i]; //get each item
@2,@    if (item.type !== "Fence") {
@2,@        notFence.push(item); //add qualifying items to array
@2,@    }
@3,@    if (item.y < 10) {
@3,@        lowAltitude.push(item);
@3,@    }
@5,@    var type = item.type;
@6,@    if (typeof typeCounter[type] == "undefined") {
@6,@        typeCounter[type] = 0;
@6,@    }
@5,@    typeCounter[type]++;
@1,@}
@7,@
@7,@console.log("All non-fence items: ", notFence);
@7,@console.log("All low-altitude items: ", lowAltitude);
@8,@
@8,@for (var type in typeCounter) {
@8,@    var count = typeCounter[type];
@8,@    console.log(count + " items of type " + type);
@8,@}
@@c:0;We'll start by defining our array of game objects. We have only three, and we're going to filter on fairly broad terms, but this would easily scale to much larger data sets.

In this code, we're going to try to assemble three pieces of data: an array containing only non-Fence items, an array of anything positioned close to the floor (y < 20), and a count of each item type.@@
@@c:1;Although we're working with objects, the actual collection that we're looping over is an array. Even with the new kinds of loops we've learned, the old-fashioned array loop never goes out of style.@@
@@c:2;We'll first create a filtered list of items that are not scenery, using the aptly-named notFence variable. As we run through the list, if an item matches our requirements, we'll push it into this list.@@
@@c:3;We can do the same thing for items that are close to the ground, just by checking their y property and pushing them into the lowAltitude array. Some items will end up in both places--that's okay. You can have an item stored in multiple arrays, just as you can have the same value in multiple variables.@@
@@c:4;Our third question, counting the individual object types, is more difficult. For this, we're going to use an object as a named collection. We'll call it typeCounter;@@
@@c:5;Inside our loop, we're going to get the item type, and use that as a key for lookup inside typeCounter.@@
@@c:6;Of course, this code is not going to work very well, since we haven't create anything at typeCounter[type] yet, whatever that may be. We can check to see if we've encountered that type before by testing for undefined. If the property hasn't been defined yet, we'll set it equal to 0 before performing our addition.@@
@@c:7;Finally, we have to log these out. The notFence and lowAltitude arrays are pretty easy to log out via console.log().@@
@@c:8;Our list of item counts by type is a little more complex. We could log it out by just passing it to console.log(), as we did with the arrays, but let's loop over the object and extract a more readable count instead.@@</script>
</div>
<script>
require(['jquery', 'meta/TLPlayer'], function($, Player) {
  var element = $('#game-objects');
  var player = new Player();
  var diff = element.find('script[type="text/timelapse"]');
  var revUL = element.find('ul.revision-list');
  player.load(diff.html()).done(function() {
    player.timelapse.revisions.forEach(function(item, i) {
      var li = $('<li>');
      li.html(i + 1);
      li.attr('data-revision', i);
      revUL.append(li);
    });
    player.connect({
      code: element.find('code.revision'),
      comments: element.find('.comments')
    })
    player.switch(0);
    element.find('li:first').addClass('active');
    element.find('.controls').on('click', 'li', function() {
      var $this = $(this);
      element.find('.active').removeClass('active');
      $this.addClass('active');
      player.switch($this.attr('data-revision'));
    });
    /*element.find('.comments').slideUp();
    element.find('.comments-bar').on('click', function() {
      element.find('.comments').slideToggle();
    });*/
    ['first', 'previous', 'next', 'last'].forEach(function(jump) {
      element.find('.' + jump).click(function() {
        player[jump]();
        element.find('.active').removeClass('active');
        element.find('li[data-revision=' + player.current + ']').addClass('active');
      });
    });
  });
});
</script>

<h2>Exercises and Practice Questions</h2>

<ol>
  <li> Pick three random objects from the room around you. Describe those as JavaScript objects. Try to pick at least one container-like object, which holds other things, and think about how to simulate its contents.
  <li> Write a JavaScript snippet that counts the number of times that each letter occurs in a given piece of text, using an object to store the counts for each letter. To make this easier, it helps to remember that you can treat a string as an array in most browsers.
  <li> In the earthquake example above, we found the highest magnitude of earthquake. Write another loop that will find the average magnitude of all the quake objects.
</ol>

<script>
require(['jquery', 'google-code/prettify'], function($) {
  $('code, pre').each(function() { $(this).html($.trim(this.innerHTML)) }).addClass('prettyprint');
  PR.prettyPrint();
});
</script>
  </div>
</body>
</html>
